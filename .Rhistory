CombinedDt.1, CombinedDt.2, RecentArrival.1, RecentArrival.2,
County, Sex, Age, Spoligotype, MIRUDiff, MIRUDiffG, GENType,
PCRType, Lineage, CountryOfBirth, Smear, SharedResG, AnyImmunoSup,
TimeCat, CombinedDiff, CombinedDiffY, ContactTrain)
#Creating a gold standard based on the GenType
%>% mutate(miruLink = ifelse(GENType == "Same" & County == "Same", TRUE,
ifelse(MIRUDiffG == "4+", FALSE, NA)))
)
massInd <- massInd %>% replace_na(list(HaveContInv = "No"))
## Individual Level ##
indCat <- c("Sex", "Age", "USBorn", "RecentArrival", "Smear", "AnyImmunoSup",
"ISUSRIF", "ISUSINH",  "ISUSPZA", "ISUSEMB", "ISUSSM", "ISUSETH",
"County", "Lineage", "HaveContact", "HaveContInv")
covarInd <- CreateTableOne(vars = indCat, factorVars = indCat, data = massInd)
covarInd <- as.data.frame(print(covarInd, showAllLevels = TRUE, missing = TRUE))
sum(is.na(massInd$GENType))
sum(is.na(massInd$Spoligotype))
sum(is.na(massInd$MIRUComb))
## Pair Level ##
pairCat <- c("Sex", "Age", "CountryOfBirth", "Smear", "AnyImmunoSup",
"SharedResG", "County", "GENType", "TimeCat", "ContactTrain")
covarPair <- CreateTableOne(vars = pairCat, factorVars = pairCat, data = orderedMass)
covarPair <- as.data.frame(print(covarPair, showAllLevels = TRUE))
#Stratified by contact group
covarPairC <- CreateTableOne(vars = pairCat, factorVars = pairCat,
data = orderedMass, strata = "ContactTrain", test = FALSE)
covarPairC <- as.data.frame(print(covarPairC, showAllLevels = TRUE))
covarPairAll <- cbind.data.frame(covarPair, covarPairC)
table(orderedMass$Lineage, useNA = "always")
prop.table(table(orderedMass$Lineage, useNA = "always"))
#One possible clustering method and cutoff
resMassCov2C <- clusterInfectors(df = resMassCov2, indIDVar = "StudyID", pVar = "pScaledI",
clustMethod = "hc_absolute", cutoff = 0.1)
load_all("../nbTransmission")
#One possible clustering method and cutoff
resMassCov2C <- clusterInfectors(df = resMassCov2, indIDVar = "StudyID", pVar = "pScaledI",
clustMethod = "hc_absolute", cutoff = 0.1)
topClust <- resMassCov2C %>% filter(cluster == 1)
length(unique(topClust$StudyID.2))
length(unique(topClust$StudyID.2)) / length(unique(resMassCov2C$StudyID.2))
ggplot(data = resMassCov2C %>% filter(StudyID.2 >= 26, StudyID.2 <= 50),
aes(x = pRank, y = pScaledI, color = cluster)) +
geom_point() +
facet_wrap(~StudyID.2, scales = "free") +
theme(legend.position = "none")
ggplot(data = resMassCov2C) +
geom_histogram(aes(x = pScaledI, fill = cluster),
position = "dodge", binwidth = 0.1) +
facet_wrap(factor(ContactTrain)~factor(GENType),
drop = FALSE, scales = "free_y")
#### Figure: Plot of Probabilities Colored by Cluster ####
resMassCov2C <- resMassCov2C %>% mutate(clusterC = ifelse(cluster == 1, "Top Cluster",
"Bottom Cluster"))
ggplot(data = resMassCov2C) +
geom_histogram(aes(x = pScaledI, fill = clusterC),
binwidth = 0.1, position = "dodge") +
scale_y_continuous(name = "Number of Case Pairs") +
scale_x_continuous(name = "Relative Transmission Probability") +
scale_fill_grey(start = 0.6, end = 0.3) +
facet_zoom(ylim = c(0, 200)) +
theme_bw() +
theme(legend.position = "bottom",
legend.title = element_blank(),
axis.title.y = element_text(margin = margin(t = 0, r = 10, b = 0, l = 0)),
axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0))) +
ggsave(file = "../Figures/MassProbs.png",
width = 8, height = 6, units = "in", dpi = 300)
ggplot(data = resMassCov2C) +
geom_histogram(aes(x = pScaledI, fill = clusterC),
binwidth = 0.1, position = "dodge") +
scale_y_continuous(name = "Number of Case Pairs") +
scale_x_continuous(name = "Relative Transmission Probability") +
scale_fill_grey(start = 0.6, end = 0.3) +
facet_zoom(ylim = c(0, 300)) +
theme_bw() +
theme(legend.position = "bottom",
legend.title = element_blank(),
axis.title.y = element_text(margin = margin(t = 0, r = 10, b = 0, l = 0)),
axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0))) +
ggsave(file = "../Figures/MassProbs.png",
width = 8, height = 6, units = "in", dpi = 300)
#Exploring contact pairs
contactPairs <- (resMassCov
%>% filter(ContactTrain == TRUE)
%>% select(EdgeID, StudyID.1, StudyID.2, CombinedDt.1, CombinedDt.2,
pScaledI, pAvg, nSamples, Spoligotype, MIRUDiffG,
County, CountryOfBirth)
)
highProb <- resMassCov %>% filter(pScaledI > 0.3)
table(highProb$GENType, useNA = "ifany")
table(highProb$ContactTrain, useNA = "ifany")
pairCat2 <- c("Sex", "Age", "CountryOfBirth", "Smear", "AnyImmunoSup",
"SharedResG", "County", "GENType", "TimeCat")
covarPair2 <- CreateTableOne(vars = pairCat2, factorVars = pairCat2, data = orderedMass)
covarPair2 <- as.data.frame(print(covarPair2, showAllLevels = TRUE))
covarPairH <- CreateTableOne(data = highProb, vars = pairCat2, factorVars = pairCat2)
covarPairH <- as.data.frame(print(covarPairH, showAllLevels = TRUE))
covarPairAll2 <- cbind.data.frame(covarPair2, covarPairH)
siAll <- readRDS("../Datasets/MassSI.rds")
RiData <- readRDS("../Datasets/MassRi.rds")
RtData <- readRDS("../Datasets/MassRtCI.rds")
RtAvg <- readRDS("../Datasets/MassRtAvgCI.rds")
#### Table: Average Rt ####
RtAvg
#Cutting the outbreak
totalTime <- max(RtData$timeRank) - min(RtData$timeRank)
monthCut1 <- ceiling(0.1 * totalTime)
monthCut2 <- ceiling(0.8 * totalTime)
#Histogram of case counts
ggplot(data = massInd) +
geom_histogram(aes(x = CombinedDt))
ggplot(data = massInd %>% filter(HaveContInv == "Yes" | HaveContact == TRUE)) +
geom_bar(aes(x = factor(year(CombinedDt)), fill = HaveContact),
position = "dodge")
library(lubridate)
ggplot(data = massInd %>% filter(HaveContInv == "Yes" | HaveContact == TRUE)) +
geom_bar(aes(x = factor(year(CombinedDt)), fill = HaveContact),
position = "dodge")
ggplot(data = massInd %>% filter(HaveContInvTrain == TRUE)) +
geom_bar(aes(x = factor(year(CombinedDt)), fill = is.na(ContactGroup)),
position = "dodge")
#Histogram of cases with contact investigations
ggplot(data = massInd %>% filter(HaveContInv == "Yes" | HaveContact == TRUE)) +
geom_bar(aes(x = factor(year(CombinedDt)), fill = HaveContact),
position = "dodge")
ggplot(data = RtData, aes(x = timeRank, y = Rt)) +
geom_point() +
geom_line() +
geom_errorbar(aes(ymin = ciLower, ymax = ciUpper), width = 0.7, color = "grey40") +
scale_y_continuous(name = "Monthly Effective Reproductive Number") +
scale_x_continuous(name = "Year of Observation", breaks = seq(3, 89, 12),
labels = seq(2010, 2017, 1)) +
geom_vline(aes(xintercept = monthCut1), linetype = "dotted", size = 0.7) +
geom_vline(aes(xintercept = monthCut2), linetype = "dotted", size = 0.7) +
geom_hline(data = RtAvg, aes(yintercept = RtAvg), size = 0.7) +
theme_bw() +
geom_hline(data = RtAvg, aes(yintercept = ciLower), linetype = "dashed",
size = 0.5, color = "grey40") +
geom_hline(data = RtAvg, aes(yintercept = ciUpper), linetype = "dashed",
size = 0.5, color = "grey40") +
theme(panel.grid.minor = element_blank(),
axis.text.x = element_text(size = 11),
axis.text.y = element_text(size = 11),
axis.title.y = element_text(margin = margin(t = 0, r = 10, b = 0, l = 0),
size = 12),
axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0),
size = 12))
#Function to take the SI results and format to a nice table
formatSITable <- function(siTable){
siTable2 <- (siTable
%>% mutate(npIncluded = paste0(nIndividuals, " (",
100 * round(pCluster, 3), ")"),
mean = paste0(round(meanSI, 2), " (", round(meanCILB, 2),
", ", round(meanCIUB, 2), ")"),
median = paste0(round(medianSI, 2), " (", round(medianCILB, 2),
", ", round(medianCIUB, 2), ")"),
sd = paste0(round(sdSI, 2), " (", round(sdCILB, 2),
", ", round(sdCIUB, 2), ")"))
%>% select(label, cutoff, npIncluded, mean, median, sd)
)
return(siTable2)
}
#Tables of results
pooled <- formatSITable(siAll %>% filter(cutoff == "pooled"))
siHC <- formatSITable(siAll %>% filter(clustMethod == "hc_absolute"))
siKD <- formatSITable(siAll %>% filter(clustMethod == "kd"))
#Creating alternative label
siAll <- siAll %>% mutate(label2 = gsub("[A-Z]{2}: ", "", label))
## Creating long dataset ##
meanDf <- (siAll
%>% select(label2, clustMethod, cutoff, shape, scale,
est = meanSI, cilb = meanCILB, ciub = meanCIUB)
%>% mutate(Parameter = "Mean")
)
medianDf <- (siAll
%>% select(label2, clustMethod, cutoff, shape, scale,
est = medianSI, cilb = medianCILB, ciub = medianCIUB)
%>% mutate(Parameter = "Median")
)
sdDf <- (siAll
%>% select(label2, clustMethod, cutoff, shape, scale,
est = sdSI, cilb = sdCILB, ciub = sdCIUB)
%>% mutate(Parameter = "Standard Deviation")
)
siAllLong <- bind_rows(meanDf, medianDf, sdDf)
#Finding the width for the error bars
errorWidth <- (siAllLong
%>% filter(cutoff != "pooled")
%>% group_by(clustMethod)
%>% summarize(range = max(as.numeric(cutoff)) - min(as.numeric(cutoff)),
width = range / 40)
%>% select(-range)
)
siAllLong2 <- (siAllLong
%>% full_join(errorWidth, by = "clustMethod")
%>% mutate(clustMethod = ifelse(clustMethod == "hc_absolute",
"Hiearchical Clustering",
"Kernel Density Estimation"))
)
ggplot(data = siAllLong2 %>% filter(cutoff != "pooled"),
aes(x = as.numeric(cutoff), y = est, color = label2)) +
geom_point() +
geom_errorbar(aes(ymin = cilb, ymax = ciub, width = width)) +
geom_hline(data = siAllLong2 %>% filter(cutoff == "pooled"),
aes(yintercept = est, color = label2)) +
geom_hline(data = siAllLong2 %>% filter(cutoff == "pooled"),
aes(yintercept = cilb, color = label2), linetype = "dotted") +
geom_hline(data = siAllLong2 %>% filter(cutoff == "pooled"),
aes(yintercept = ciub, color = label2), linetype = "dotted") +
facet_grid(Parameter~clustMethod, scales = "free") +
scale_x_continuous(name = "Clustering Cutoff/Binwidth") +
scale_y_continuous(name = "Estimate in Years") +
theme_bw() +
scale_color_grey(start = 0.6, end = 0.3) +
theme(legend.position = "bottom",
legend.title = element_blank(),
axis.text.x = element_text(size = 10),
axis.text.y = element_text(size = 10),
axis.title.y = element_text(margin = margin(t = 0, r = 10, b = 0, l = 0),
size = 11),
axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0),
size = 11))
siKD
formatSITable(siAll %>% filter(cutoff == "pooled"))
#### Supplementary Tables: Detailed Serial Interval Results ####
siHC <- formatSITable(siAll %>% filter(clustMethod == "hc_absolute"))
siKD <- formatSITable(siAll %>% filter(clustMethod == "kd"))
#Sarah Van Ness
#Boston University
#Dissertation
##################################################################################
# This program tests the effect of changing the genome length
##################################################################################
rm(list = ls())
options(scipen=999)
library(TransPhylo)
library(phangorn)
library(reshape2)
library(dplyr)
library(tidyr)
library(purrr)
library(lubridate)
library(glmnet)
library(FSelector)
library(caret)
library(gtools)
source("TransPhylo/SimulateOutbreakS.R")
#### Batch Mode ####
# setwd("/project/sv-thesis/dissertation_code/")
# #Finding the task number for the run
# iTask <- as.numeric(Sys.getenv("SGE_TASK_ID"))
# #The number of simulations per split
# nSim <- 10
#### Interactive Mode ####
setwd("~/Boston University/Dissertation/dissertation_code")
iTask <- 1
nSim <- 2
################## Setting the oubreak parameters #################
#Effective population size times generation time (1 day or 1/365 years)
neg <- 0.25
pi <- 1
#Sets reproductive number to off.r if off.p = 0.5
off.r <- 1.2
off.p <- 0.5
#From Yincheng's work
w.shape <- 1.05
w.scale <- 1 / (0.0014 * 365)
ws.shape <- w.shape
ws.scale <- w.scale
#Total sample size
sampleSize <- 200
#Do you want multiple outbreaks
multOutbreaks <- FALSE
rootseq <- NULL
#Date of observation
observationDate = "infectionDate"
#Probability calculation parameters
covariates <- c("Y1", "Y2", "Y3", "Y4", "timeCat1")
pTraining <- 0.5
goldStandard <- "transmission"
scheme = "info"
################# Testing genotype length ###############
#Setting seed here so same outbreak is used each time
set.seed(15039)
#If multOutbreaks = FALSE, simulating single outbreak with the desired sample size
simu <- simulateOutbreakS(neg = neg, pi = pi, off.r = off.r, off.p = off.p,
w.shape = w.shape, w.scale = w.scale,
ws.shape = ws.shape, ws.scale = ws.scale,
nSampled = sampleSize,
dateStartOutbreak = 1980, dateT = 2000)
#Extract the phylogenetic tree and convert it to a phylo object
p <- phyloFromPTree(extractPTree(simu))
calcDistance <- function(length){
#Simulating the sequences
rate <- 0.5 / length
seq <- simSeq(p, l = length, rate = rate, rootseq = rootseq)
names(seq) <- 10000 + as.numeric(names(seq))
#Making the sequences into a DNAbin object
seqBin <- as.DNAbin(seq)
snpDist <- dist.gene(seqBin)
snpDistDf <- melt(as.matrix(snpDist), varnames = c("individualID.1", "individualID.2"))
snpDistDf <- (snpDistDf
%>% rename(snpDist = value)
%>% filter(individualID.1 > individualID.2)
)
pLow <- round(100 * sum(snpDistDf$snpDist < 2) / nrow(snpDistDf), 0)
pHigh <- round(100 * sum(snpDistDf$snpDist > 12) / nrow(snpDistDf), 0)
results <- c("length" = length, round(summary(snpDistDf$snpDist), 0),
"p<2" = pLow, "P>12" = pHigh)
#hist(snpDistDf$snpDist, breaks = 30)
return(results)
}
set.seed(iTask * 1000 + 1)
results <- NULL
for (i in 1:nSim){
#lengths <- c(50, 100, 500, 1000, 5000, 10000, 50000, 100000, 4400000)
lengths <- c(50, 100, 500)
for (l in lengths){
rTemp <- calcDistance(l)
rTemp$runID <- paste0(iTask, "_", i)
results <- bind_rows(results, rTemp)
print(paste0("Finished simulated length of ", l))
}
print(paste0("Finished run ", i))
}
source("TransPhylo/SimulateOutbreakS.R")
setwd("~/Boston University/Dissertation/dissertation_code")
source("SimulateOutbreakS.R")
#If multOutbreaks = FALSE, simulating single outbreak with the desired sample size
simu <- simulateOutbreakS(neg = neg, pi = pi, off.r = off.r, off.p = off.p,
w.shape = w.shape, w.scale = w.scale,
ws.shape = ws.shape, ws.scale = ws.scale,
nSampled = sampleSize,
dateStartOutbreak = 1980, dateT = 2000)
#Extract the phylogenetic tree and convert it to a phylo object
p <- phyloFromPTree(extractPTree(simu))
calcDistance <- function(length){
#Simulating the sequences
rate <- 0.5 / length
seq <- simSeq(p, l = length, rate = rate, rootseq = rootseq)
names(seq) <- 10000 + as.numeric(names(seq))
#Making the sequences into a DNAbin object
seqBin <- as.DNAbin(seq)
snpDist <- dist.gene(seqBin)
snpDistDf <- melt(as.matrix(snpDist), varnames = c("individualID.1", "individualID.2"))
snpDistDf <- (snpDistDf
%>% rename(snpDist = value)
%>% filter(individualID.1 > individualID.2)
)
pLow <- round(100 * sum(snpDistDf$snpDist < 2) / nrow(snpDistDf), 0)
pHigh <- round(100 * sum(snpDistDf$snpDist > 12) / nrow(snpDistDf), 0)
results <- c("length" = length, round(summary(snpDistDf$snpDist), 0),
"p<2" = pLow, "P>12" = pHigh)
#hist(snpDistDf$snpDist, breaks = 30)
return(results)
}
set.seed(iTask * 1000 + 1)
results <- NULL
for (i in 1:nSim){
#lengths <- c(50, 100, 500, 1000, 5000, 10000, 50000, 100000, 4400000)
lengths <- c(50, 100, 500)
for (l in lengths){
rTemp <- calcDistance(l)
rTemp$runID <- paste0(iTask, "_", i)
results <- bind_rows(results, rTemp)
print(paste0("Finished simulated length of ", l))
}
print(paste0("Finished run ", i))
}
View(results)
#hist(snpDistDf$snpDist, breaks = 30)
return(as.data.frame(results))
calcDistance <- function(length){
#Simulating the sequences
rate <- 0.5 / length
seq <- simSeq(p, l = length, rate = rate, rootseq = rootseq)
names(seq) <- 10000 + as.numeric(names(seq))
#Making the sequences into a DNAbin object
seqBin <- as.DNAbin(seq)
snpDist <- dist.gene(seqBin)
snpDistDf <- melt(as.matrix(snpDist), varnames = c("individualID.1", "individualID.2"))
snpDistDf <- (snpDistDf
%>% rename(snpDist = value)
%>% filter(individualID.1 > individualID.2)
)
pLow <- round(100 * sum(snpDistDf$snpDist < 2) / nrow(snpDistDf), 0)
pHigh <- round(100 * sum(snpDistDf$snpDist > 12) / nrow(snpDistDf), 0)
results <- c("length" = length, round(summary(snpDistDf$snpDist), 0),
"p<2" = pLow, "P>12" = pHigh)
#hist(snpDistDf$snpDist, breaks = 30)
return(as.data.frame(results))
}
set.seed(iTask * 1000 + 1)
results <- NULL
fullResults <- readRDS("../Simulation_Results_GT/FullGenomeTest.rds")
fullResults
genomeRes <- readRDS("../Simulation_Results_GT/GenomeTest_1.rds")
for(i in 2:10){
rTemp <- readRDS("../Simulation_Results/GenomeTest_1.rds")
genomeRes <- bind_rows(genomeRes, rTemp)
}
genomeRes <- readRDS("../Simulation_Results_GT/GenomeTest_1.rds")
for(i in 2:10){
rTemp <- readRDS(paste0("../Simulation_Results_GT/GenomeTest_", i, ".rds"))
genomeRes <- bind_rows(genomeRes, rTemp)
}
longRes <- (genomeRes
%>% gather(stat, value, -length, -runID)
%>% filter(stat != "Min.")
%>% mutate(statName = factor(stat, levels = c("1st Qu.", "Median",
"3rd Qu.", "Max.",
"p<2", "P>12"),
labels = c("1st Qu. of SNP Distance",
"Median SNP Distance",
"3rd Qu. of SNP Distance",
"Maxium SNP Distance",
"Percent with <2 SNPs",
"Percent with >12 SNPs")))
)
ggplot(data = longRes %>% filter(!is.na(statName)),
aes(x = factor(length), y = value,
color = factor(length), fill = factor(length))) +
geom_violin(alpha = 0.75, draw_quantiles = 0.5) +
facet_wrap(~ statName, scales = "free_y") +
theme_bw() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_fill_discrete(name = "Genome Length") +
scale_color_discrete(name = "Genome Length") +
scale_y_continuous(name = "Value") +
scale_x_discrete(name = "Genome Length")
ggplot(data = longData, aes(x = Scenario, y = value,
fill = Scenario, color = Scenario)) +
geom_violin(alpha = 0.75) +
scale_x_discrete(name = "Scenario", breaks = NULL) +
scale_y_continuous(name = "Value") +
facet_wrap(~ metric, nrow = 3, ncol = 3) +
theme_bw() +
theme(legend.position = "bottom", legend.title = element_blank(),
legend.spacing.x = unit(0.25, "cm"))
#Violin plot of performance metrics over all runs
ggplot(data = longRes, aes(x = Scenario, y = value,
fill = Scenario, color = Scenario)) +
geom_violin(alpha = 0.75) +
scale_x_discrete(name = "Scenario", breaks = NULL) +
scale_y_continuous(name = "Value") +
facet_wrap(~ metric, nrow = 3, ncol = 3) +
theme_bw() +
theme(legend.position = "bottom", legend.title = element_blank(),
legend.spacing.x = unit(0.25, "cm"))
View(genomeRes)
table(genomeRes$runID)
table(genomeRes$length)
sum(is.na(genomeRes$Mean))
ggplot(data = longRes %>% filter(!is.na(statName)),
aes(x = factor(length), y = value,
color = factor(length), fill = factor(length))) +
geom_violin(alpha = 0.75, draw_quantiles = 0.5) +
facet_wrap(~ statName, scales = "free_y") +
theme_bw() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_fill_discrete(name = "Genome Length") +
scale_color_discrete(name = "Genome Length") +
scale_y_continuous(name = "Value") +
scale_x_discrete(name = "Genome Length") +
ggsave(file = "../Figures/GenomeTest.png",
width = 8, height = 4, units = "in", dpi = 300)
?nbProbabilities
setwd("~/Boston University/Dissertation")
rm(list = ls())
set.seed(103020)
library(dplyr)
library(purrr)
library(tidyr)
library(devtools)
#Sourcing functions
load_all("../nbTransmission")
source("nbSimulation/PerformRandom.R")
source("nb/Simulation/PerformInterval.R")
#Reading in datasets from HamburgPrep.R
hamInd <- readRDS("Datasets/HamburgInd.rds")
hamPair <- readRDS("Datasets/HamburgPair.rds")
source("nbSimulation/PerformInterval.R")
setwd("~/Boston University/Dissertation/nbPaper1")
source("../nbSimulation/SimOutbreak.R")
setwd("~/Boston University/Dissertation")
rm(list = ls())
set.seed(103020)
library(dplyr)
library(tidyr)
library(naniar)
library(lubridate)
library(reshape2)
library(readxl)
#Reading in the original dataset
massInd <- read_excel("Datasets/genotyping IRB data set-  jan 2010 to dec 2016 ver 2.5.xlsx",
na = c("", "#N/A"))
#Reading in my contact groupings
massContacts <- read.csv("DPH_ContactGroups.csv")
#Reading in my contact groupings
massContacts <- read.csv("Datasets/DPH_ContactGroups.csv")
countyMatrix <- read.csv("Datasets/DPH_Counties.csv", row.names = "RowNames",
stringsAsFactors = FALSE)
setwd("~/Boston University/Dissertation/nbPaper2")
source("../ReplaceMerge.R")
load_all("../nbTransmission")
source("../nbSimulation/SimOutbreak.R")
source("../nbSimulation/SimulateOutbreakS.R")
source("../nbSimulation/SimCovariates.R")
source("../nbSimulation/SimEvaluate.R")
setwd("~/Boston University/Dissertation/nbPaper2")
source("../ReplaceMerge.R")
source("../dissertation_code/ReplaceMerge.R")
